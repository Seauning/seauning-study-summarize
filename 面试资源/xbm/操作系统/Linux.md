---
typora-copy-images-to: img
---

![1649312878377](../img/1649312878377.png)

# Linux命令

## 文件操作

- touch：创建一个空文件，如果文件存在，则会更改文件的访问时间和修改时间

  ```
  touch file
  ```

- cp：用来复制文件和目录，同时借助某些选项还可以实现复制整个目录，以及对比两个文件的新旧予以升级等功能。

  cp [选项参数] fileSource1 fileSource2 目标文件夹

  cp -r 源文件夹 目标文件夹

  ```
  ## 将当前目录test/下所有文件复制到新目录newDir下
  cp -r test/ newDir
  ```

- mv：用来移动文件夹、文件或者修改文件名、目录名

  ```
  ## 修改文件名称
  mv test.txt test1.txt
  ## 将test/目录下的文件移到newDir下
  mv test/ newDir
  ```

- rm：用来删除一个文件或者目录

  rm  [options] fileName/filePath

  -i | 删除前逐一询问确认
  -f | 即使原档案属性设置为只读，也可强制删除，无需确认
  -r | 将目录及以下之档案亦逐一递归删除

  ```
  rm -rf test.txt
  ```

- mkdir：创建目录

  ```
  ## 确保目录名称存在，不存在就新建一个
  mkdir -p dirName
  ```

- tar：将各文件归档，具有打包和压缩功能，普通文件和文件夹可以被打包成 xxx.tar，如果要压缩，则是在打包之后再压缩，格式是 xxx.tar.gz

  ```
  tar [-cxtzjvfpPN] 文件与目录
  常用参数：描述
  -c ：建立一个压缩文件 
  -x ：解开一个压缩文件
  -t ：查看tarfile 里面的文件！特别注意，c/x/t 仅能存在一个，不可同时存在
  -z ：用 gzip 解压缩
  -j ：用 bzip2 解压缩
  -v ：压缩的过程中显示文件，这个常用，但不建议用
  -f ：使用档名，在 f 之后要立即接档名！例如使用『 tar -zcfv tfile sfile』就是错误的写法，要写成 『tar -zcvf tfile sfile』才对喔
  -p ：使用原文件的原来属性（属性不会依据使用者而变）
  -P ：（大写P）使用绝对路径来压缩
  ```

  ```
  ## 打包不压缩/home/temp目录
  tar -cf target.tar /home/temp
  ## 打包并压缩/home/temp目录
  tar -zcf target.tar.gz /home/temp
  ## 解压target.tar.gz
  tar -zxf target.tar.gz 
  ```

- jar：jar能够将多个源码、资源等文件打包并压缩到一个归档文件中。也支持更新、查看、提取。更重要的是，jar包可以按照各种java程序运行的约定去打包。

  ```
  ## 利用hello目录创建hello.jar包
  jar -cf hello.jar hello
  ## 将HelloWorld.java添加到hello.jar包中
  jar -uf hello.jar HelloWorld.java
  ## 解压hello.jar至当前目录
  jar -xf hello.jar
  ```

- chmod：控制用户对文件的权限的命令

- ln：当我们需要在不同的目录，用到相同的文件时，又不想浪费空间复制相同的文件，可以用ln链接它，相当于创建一个快捷图标

  ```
  options 参数 | 描述
  -b | 删除，覆盖以前建立的链接
  -d | 允许超级用户制作目录的硬链接
  -f | 强制执行
  -i | 交互模式，文件存在则提示用户是否覆盖
  -n | 把符号链接视为一般目录
  -s | 软链接(符号链接)
  ```

  inode：inode是类Unix文件系统中用来描述文件系统对象（比如文件或文件夹）的一种数据结构。它存储着文件的各种属性（最近一次inode变动的时间、最近一次访问的时间、最近一次修改的时间等元信息，以及权限信息等）。文件夹是一组inode，包括自身的入口、父节点的入口以及所有子节点。

  **硬链接**：一般来说，inode与文件名、文件数据是一对一的关系，但我们可以通过shell命令让多个文件名指向同一个inode，这种就是硬链接，注意 只能对已存在的文件进行创建。也不能对目录进行创建硬链接。

  ```
  ln test.txt test_hard.txt
  ```

  ![1650370757192](img/1650370757192.png)

  **软链接**：相当于windows系统中桌面快捷方式，会创建新的inode结点并指向源文件

  ![1650370934628](img/1650370934628.png)

  **对比：**

  ![链接](../img/硬软链接.awebp)

  **文件重命名或文件移动**

  文件重命名和文件移动对于Linux系统来说都是文件绝对路径的更改。对硬链接来说，文件重命名或文件移动不会改变链接指向，而对软链接来说，文件重命名或文件移动则使链接断开，这时通过软链接修改文件内容时会重新创建一个新的inode，跟原文件名和文件数据块关联。

  **文件删除**

  `rm`命令或者nodejs的`unlink`其实是将inode的链接数减1。对于前文的硬链接，删除`test_hard.txt`使得`inode1`的链接数变成1，当链接数变成0时，系统就会释放掉这个inode，之后再创建的新文件就可以使用该inode的inode number了。这时没有inode指向文件数据block，所以文件找不到了。但实际上文件数据还存在硬盘中，所以经常能看到网上有一些帮助恢复误删的文件的工具。软链接inode链接数为1，删除软链接则系统释放该inode。

  **链接文件和文件夹**

  软链接可以链接文件和文件夹，但硬链接只能链接文件。

  **不同文件系统创建链接**

  软链接可以跨不同的文件系统创建，但是硬链接不行，因为硬链接是共用一个inode，而不同的文件系统有不同的inode table。

  ## 应用场景

  ### 硬链接

  1. 文件备份：为了防止重要的文件被误删，文件备份是一种好的办法，但拷贝文件会带来磁盘空间的消耗。硬链接能不占用磁盘空间实现文件备份。
  2. 文件共享：多人共同维护同一份文件时，可以通过硬链接的方式，在私人目录里创建硬链接，每个人的修改都能同步到源文件，但又避免某个人误删就丢掉了文件的问题。
  3. 文件分类：不同的文件资源需要分类，比如某个电影即是的分类是外国、悬疑，那我们可以在外国的文件夹和悬疑的文件夹里分别创建硬链接，这样可以避免重复拷贝电影浪费磁盘空间。有人可能说，使用软链接不也可以吗？是的，但不太好。因为一旦源文件移动位置或者重命名，软链接就失效了。

  ### 软链接

  1. 快捷方式：对于路径很深的文件，查找起来不太方便。利用软链接在桌面创建快捷方式，可以迅速打开并编辑文件。
  2. 灵活切换程序版本：对于机器上同时存在多个版本的程序，可以通过更改软链接的指向，从而迅速切换程序版本。[这里](https://link.juejin.cn?target=https%3A%2F%2Fwww.eet-china.com%2Fmp%2Fa76055.html)提到了python版本的切换可以这么做。
  3. 动态库版本管理：不是很懂，具体可以看[这里](https://link.juejin.cn?target=https%3A%2F%2Fwww.eet-china.com%2Fmp%2Fa76055.html)。

  ## 总结

  1. Linux系统通过inode管理文件，inode存储着文件字节数、文件权限、链接数、数据block位置等信息。
  2. 硬链接与源文件共用inode，除了文件名不同，其他与源文件一样。不能对文件夹创建硬链接，不能对不同的文件系统的文件创建硬链接。
  3. 软链接类似于windows的快捷方式，有独立的inode。可以对文件夹或不同文件系统的文件创建软链接。
  4. 硬链接和软链接修改文件内容都会同步到源文件，因为本质上它们都是指向源文件的数据block。

## 文件查找

- whereis：显示命令路径以及命令相关的帮助文件路径

  -b:查找可执行文件，-m:查找帮助文件，-s:查找源代码文件

  ```
  whereis pwd #查找pwd命令的相关文件
  whereis -m pwd #查找pwd命令的帮助文件
  ```

- locate：从linux内置的索引数据库/var/lib/mlocate/mlocate.db查找文件，查询速度超快

  - -i：忽略大小写
  - -l：仅输出几行的意思，例如输出5行则是-l 5；
  - -r :后面可接正则表达式的显示方式
  - -c：不输出文件名，仅计算找到的文件数量；

  ```
  locate pwd # 查找pwd命令相关的所有文件
  locate /etc/sh # 查找etc目录下以sh开头的文件
  locate -c /etc/sh #查找etc目录下以sh开头的文件数
  locate -l 4 passwd # 是输出前4行
  ```

- find:从文件系统中进行搜索，默认从根目录搜索，速度很慢，一般是搜索指定目录下符合条件的文件。

  - -name：按照名称查找
  - -type：安装文件类型查找（“f”标识文件，"d"表示文件夹）
  - -size：根据大小查找
  - -perm：根据权限查找
  - -mtime：根据修改时间查找
  - -atime：根据访问时间查找

  ```
  find ./ -name test.sh # 查看当前目录下名为test.sh的文件
  find ./ -name '*.sh' # 查找当前目录下后缀为sh的文件。
  find /etc -type f # 查找etc目录下的所有文件
  find /etc -type d # 查找etc目录下的所有文件夹
  find /home -size 10M #  查找home目录下等于10M的文件
  find /home -size +10M # 查找home目录下大于10M的文件
  find /home -size +5M -size -10M # 查找home目录下大于5M小于10M的文件
  find /home -perm 777 # 查找home目录下权限为777的文件或目录
  find / -mtime -3 #查找3天内修改过的文件
  find / -atime -3 #查找3天内访问过的文件
  ```

总结，这三个命令都是查找文件的，`whereis`及`locate`都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找真实的文件，所以资源消耗比较大，速度慢。查找一般文件优先使用`whereis`和`locate`，两个都搜索不到或者需要使用更多条件搜索再使用find。

## 查看时间

- 查看时间和日期

  ```
  date
  ```

- 设置时间和日期

  ```
  例如：将系统日期设定成2009年11月3日的命令
  命令 ： "date -s 11/03/2009"
  将系统时间设定成下午5点55分55秒的命令
  命令 ： "date -s 17:55:55"
  ```

- 将当前时间和日期写入BIOS，避免重启后失效

  ```
  hwclock -w
  ```

  注：cal不加参数可以直接看到本月月历

## 内容查找

- grep：可以从文本文件或者管道数据流中筛选匹配的行或者数据。可以使用字符串或者正则表达式匹配。

  - -v：显示不匹配的文本（排查符合的行）
  - -i：不区分大小写
  - -n：显示匹配行及行号
  - -c：显示匹配的行数
  - -o：只输出匹配的内容
  - -w：精确匹配过滤的字符串

  ```
  grep "cpu" cpuinfo # 输出文件中包含cpu的行（加个| wc -l就可以统计行数）
  grep -v "cpu" cpuinfo # 输出文件中不包含cpu的行
  grep -n "cpu" cpuinfo # 输出文件中包含cpu的行及行号
  grep -c "cpu" cpuinfo # 输出文件中匹配cpu字符串的数量
  grep -o "cpu" cpuinfo # 只输出匹配的内容cpu
  grep -w "cpu" cpuinfo # 只匹配cpu这个单词的行
  ```

- vim:如果要查找某个字符串的位置，也可以使用vi/vim命令的搜索功能：

  1、命令模式下输入“/字符串”，例如“/cpu”

  2、输入“n”查找下一个，输入"N"查找上一个。

  ![1650357241179](img/1650357241179.png)

  vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式

## 日志查找

- 查找关键日志的行号

  ```
  cat -n test.log | grep "debug"
  ```

- 查询92行之后的日志

  ```
  cat -n test.log | tail -n +92  //-92为显示末尾92行
  ```

- 查询前20行的日志

  ```
  cat -n test.log | head -n +20
  ```

- 实时监控后100行日志

  ```
  tail -100f test.log
  ```

- 查找日志中指定内容

  ```
  1.vim test.log
  2.进入命令模式，输入"/"+查找的内容,按enter键查找
  3.然后按"n"查找下一个
  4.用esc退出查找模式，用：wq！或者：q！保存退出或者不保存退出
  ```



## 查看端口

- 查看3306端口的使用情况

  ```
  netstat -anp | grep 3306 查看3306端口的使用情况
  ```

- 查看一个服务有几个端口，比如Mysqld

  ```
  ps -ef | grep mysqld
  ```

- 查看3306端口的连接数量

  ```
  netstat -pnt | grep 3306 | wc
  ```

- 用于查看端口对应的应用程序(ps和netstat的结合)

  ```
  lsof -i : 8000
  ```

- 仅显示TCP连接

  ```
  lsof -i tcp
  ```

  ​

  ​





## 查看进程

- 查看进程（a代表all，x会显示没有控制终端的进程）

  ```
  ps -ax | less
  ```

- 按照cpu或内存用量来筛选(u代表cpu)

  ```
  ps -aux | less
  ```

- 按照cpu使用率来升序排序

  ```
  ps -aux --sort -pcpu | less
  ```

- 查找名称getty的进程

  ```
  ps -C getty
  ```

- 进程树

  ```
  pstree
  ```

  ​


## 查看内存

- 展示内存

  ```
  free -h
  ```

- 查看/proc/meminfo文件

  ```
  cat /proc/meminfo
  ```

- 对内存情况进行统计

  ```
  vmstat -s
  ```

- 输入top命令：一般用来查看系统负载、CPU利用分布情况、内存使用、每个进程的内容使用情况，使用用来监控物理内存的使用情况

  ```
  top
  ```



## 查看磁盘

- 查看磁盘已占用空间，还剩余空间

  > disk-free

  ```
  df -h（否则默认显示单位是字节，不直观）
  ```

  ![1649675982577](img/1649675982577.png)

  显示内容参数说明：

  1）Filesystem：文件系统

  2）Size： 分区大小

  3）Used： 已使用容量

  4）Avail： 还可以使用的容量

  5）Use%： 已用百分比

  6）Mounted on： 挂载点　

  相关命令：

  1）df -hl：查看磁盘剩余空间

  2）df -h：查看每个根路径的分区大小

  ​

- 查看当前目录的总大小，显示磁盘空间的使用情况

  > disk-useage

  ```
  du -sh #查看当前目录的大小
  du 文件名 #查看指定文件所占空间
  du -h  目录名 #查看指定文件夹下的所有文件大小（包含子文件夹）
  ```

- 显示文件/目录或文件系统的大小和其他统计信息

  ```
  stat file
  ```

- 查看机器所挂硬盘个数及分区情况

  ```
  fdisk -l
  ```

  ![1649677200972](img/1649677200972.png)

##  网络相关

- 查看网络路由跳转

  ```
  traceroute www.baidu.com  (ping)
  ```

- 查看路由表

  ```
  route -n  (netstat -rn)
  ```

- 删除网络网关

  ```
  route del default gw 192.168.0.1
  ```

- 添加网络网关

  ```
  route add default gw 192.168.0.1
  ```

- 查看ip

  ```
  ipconfig
  ```

  ​

  ​

  ​


## 故障排查相关

> [csdn](https://blog.csdn.net/jy02268879/article/details/108753273?ops_request_misc=&request_id=&biz_id=102&utm_term=mysql%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98%E6%80%9D%E8%B7%AF&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-108753273.142^v7^article_score_rank,157^v4^control&spm=1018.2226.3001.4187)

- 查看数据库配置的最大连接数

  ```
  show VARIABLES like 'max_connections'
  ```

  ![1649669263721](img/1649669263721.png)

- 查看当前数据库运行的所有线程、命令、状态、耗时、SQL

  ```
  SHOW PROCESSLIST
  ```

  ![1649669280163](img/1649669280163.png)

- 查看当前运行的所有事务

  ```
  select * from information_schema.INNODB_TRX
  ```

  ![1649669345507](img/1649669345507.png)

- 查看当前出现的锁

  ```
  select * from information_schema.INNODB_LOCKS
  ```

  ![1649669383207](img/1649669383207.png)

- 查看锁等待的对应关系

  ```
  select * from information_schema.INNODB_LOCK_WAITS
  ```

  ![1649669466669](img/1649669466669.png)

- 查看Innodb状态

  ```
  SHOW ENGINE INNODB STATUS
  ```

  ![1649669524086](img/1649669524086.png)

  通过上述手段，我们可以拿到死锁日志，该日志会列出死锁发生的时间，死锁相关的事务，并显示出两个事务(可惜，多事务发生死锁时，也只显示两个事务)在**发生死锁时执行的 SQL 语句、持有或等待的锁信息和最终回滚的事务**。



## 抓包



## linux连接外部

- linux连接redis

  ```
  1、进入redis文件下的bin目录下：cd /usr/local/redis/bin/
  2、执行 ./redis-cli
  ```

- linux连接mysql

  ```
  1、进入数据库：mysql -u root -p
  2、启动mysql服务： service mysql start   
  ```

  ​

# 操作系统



## 一、操作系统基础

### 1.1 什么是操作系统？

👨‍💻**面试官** ： 先来个简单问题吧！**什么是操作系统？**

🙋 **我** ：我通过以下四点向您介绍一下什么是操作系统吧！

1. **操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。**
2. **操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。** 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。
3. **操作系统存在屏蔽了硬件层的复杂性。** 操作系统就像是硬件使用的负责人，统筹着各种相关事项。
4. **操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理**。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。

![Kernel_Layout](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png)

### 1.2 用户态和内核态

👨‍💻**面试官** ：**什么是系统调用呢？** 能不能详细介绍一下。

🙋 **我** ：介绍系统调用之前，我们先来了解一下用户态和内核态。

根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：

1. **用户态**(user mode) : 只能执行那些受限级别的代码。如果需要调用特权代码需要进行内核态切换。
2. **内核态**(kernel mode):可以执行一切特权代码，内核态级别的资源有关的操作有文件管理、进程控制、内存管理等。

这种概念存在的意义就是为了进行权限保护，限定用户的程序不能乱搞操作系统。在intel cpu的设计下操作系统分为4个ring，分别是ring0，1，2，3。用户态的程序工作在3，内核态的程序处于0。

**用户态切换到内核态的3种方式：**

- **系统调用** (本质是内中断)

用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()方法，实际上就是执行了一个创建新进程的系统调用（read、write也是）。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

> 这些系统调用按功能大致可分为如下几类：
>
> - 设备管理。完成设备的请求或释放，以及设备启动等功能。
> - 文件管理。完成文件的读、写、创建及删除等功能。
> - 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
> - 进程通信。完成进程之间的消息传递或信号传递等功能。
> - 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。

- **异常** (是内中断)

当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

- **外围设备的中断** (是外中断)

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

> 硬中断的处理流程如下：
>
> - 1、**外设** 将中断请求发送给中断控制器；
> - 2、**中断控制器** 根据中断优先级，有序地将中断传递给 CPU；
> - 3、**CPU** 终止执行当前程序流，将 CPU 所有寄存器的数值保存到栈中；
> - 4、**CPU** 根据中断向量，从中断向量表中查找中断处理程序的入口地址，执行中断处理程序；
> - 5、**CPU** 恢复寄存器中的数值，返回原程序流停止位置继续执行。

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。CPU是怎么知道目前所处于的状态呢？这就要靠PSW (Program Status Word)寄存器里的值来辨别。这三种状态切换本质都是走了中断处理流程。至于从内核态切换到用户态则是通过设置PSW字段来进行转换。



#### 系统调用的实现

> [系统调用的实现](https://juejin.cn/post/6963638993913118750)

- 调用用户接口函数，用户接口封装的是系统调用的库函数

  ```
  int getpid(){
      return _syscall0(SYS_getpid);
  }
  ```

- 处理中断前要先保存上下文，然后库函数传入系统调用号、参数，以及int 80h，然后执行int指令触发软中断，中断向量号为Ox80

  （int n 就相当于发生了一个n号中断，属于软中断）

  > cpu寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。

- cpu被软中断打断后，执行中断向量对应的中断处理函数，这时便进入了内核态

- 进入内核态后，系统调用处理函数根据传递的系统调用号来调用对应的系统调用服务例程，这期间会保存所有的寄存器

- 最后就是将执行结果返回，将当前寄存器eax的值保存到上下文里面的eax处即可

![1649318473658](../img/1649318473658.png)

#### 上下文切换

上下文

> cpu寄存器，是cpu内置的容量小、速度极快的内存。而程序计数器，则是用来存储cpu正在执行的指令位置、或者即将执行的下一条指令位置。它们都是cpu在运行任何任务前，必须依赖的环境，因此叫做cpu上下文。

cpu上下文切换

> 它是指，先把前一个任务的cpu上下文（也就是cpu寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

进程从用户态到内核态的转变，需要通过系统调用来完成，系统调用的过程，会发生cpu上下文的切换。



### 1.3 文件描述符

> Linux平台万物皆文件:
>
> "Everything is a File" and Types of Files in Linux!

**文件描述符**（file descriptor，简称 fd）在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。

在 Linux 中，内核将所有的外部设备都当做一个文件来进行操作，而对一个文件的读写操作会调用内核提供的系统命令，返回一个 fd，对一个 socket 的读写也会有相应的描述符，称为 socketfd（socket 描述符），实际上描述符就是一个数字，它指向内核中的一个结构体（文件路径、数据区等一些属性)。

![文件描述符](../img/文件描述符.awebp)



### 1.4 Unix网络编程模型

> [Unix网络模型](https://juejin.cn/post/7076364933184618526)

根据 UNIX 网络编程对 IO 模型的分类，UNIX 提供了以下 5 种 IO 模型。

![](../img/unix网络模型.awebp)

#### 阻塞式IO（Blocking IO）

在阻塞式IO下，进程空间中调用recvfrom库函数进行系统调用，这期间应用进程会一直阻塞，直到系统调用返回数据包且被复制到应用进程的缓存区中或者发生错误。阻塞I/O分为如下两个阶段：

- 阶段 1：等待数据就绪。网络 I/O 的情况就是等待远端数据陆续抵达；磁盘 I/O 的情况就是等待磁盘数据从磁盘上读取到内核态内存中。
- 阶段 2：数据拷贝。出于系统安全，用户态的程序没有权限直接读取内核态内存，因此内核负责把内核态内存中的数据拷贝一份到用户态内存中。

![1649333109463](../img/1649333109463.png)

#### 非阻塞I/O（NIO）

在非阻塞I/O下，I/O操作函数将不断进行系统调用，当请求的I/O无法完成时，不会将线程阻塞，而是返回一个错误码，进程在返回之后，可以干点别的事情，然后再继续发起请求，这样进程就不会阻塞。这种循环直到I/O操作函数等到了数据，从内核拷贝到用户空间为止。

但是这种方法需要不断地轮询、重复请求，消耗了大量的 CPU 的资源。

![1649334535565](../img/1649334535565.png)

#### IO多路复用

IO多路复用IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，占用cpu。多路是指网络连接，复用指的是同一个线程。

服务器端采用单线程通过select/epoll等系统调用获取fd列表，遍历有事件的fd进行accept/recv/send，使其能支持更多的并发连接请求。

![1649341251455](../img/1649341251455.png)

##### IO多路复用的三种方式

- select

  ![](../img/select.awebp)

  ​

  ```
  // 返回值：做好准备的文件描述符的个数，超时为 0，错误为-1.
  #include <sys/select.h>
  #include <sys/time.h>

  #define FD_SETSIZE 1024
  #define NFDBITS (8 * sizeof(unsigned long))
  #define __FDSET_LONGS (FD_SETSIZE/NFDBITS)

  // 数据结构 (bitmap)
  typedef struct {
      unsigned long fds_bits[__FDSET_LONGS];
  } fd_set;

   // API
  int select(
    int max_fd, 
    fd_set *readset, 
    fd_set *writeset, 
    fd_set *exceptset, 
    struct timeval *timeout
    )   // 返回值就绪描述符的数目
    
    FD_ZERO(int fd, fd_set* fds)   // 清空集合
    FD_SET(int fd, fd_set* fds)    // 将给定的描述符加入集合
    FD_ISSET(int fd, fd_set* fds)  // 判断指定描述符是否在集合中 
    FD_CLR(int fd, fd_set* fds)    // 将给定的描述符从文件中删除
  ```

  通过select（）方法传递参数，参数有所关心的文件描述符和可以等待的最长时间。并传入数组拷贝到内存空间。调用后 select 函数后用户进程会阻塞，内核会遍历所有的fd，没有发现就绪设备就挂起当前进程，直到有fd就绪（有数据 可读、可写、或者有 except）或者主动超时。被唤醒后内核通过遍历得到已经就绪的描述符的个数，通过返回值告诉用户态。**但是不会告诉用户态具体是哪些事件就绪，需要用户态自己去事件集一个一个遍历判断。**有了这些返回信息，我们可以调用合适的 I/O 函数（比如read 或 write)，并且这些函数不会再阻塞，这样的话**用户可以在一个线程内同时处理多个 socket 的 IO 请求**。

  **select 具有 O(n) 的无差别轮询复杂度**，高并发时效率较低。 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大，而且单个进程所打开的FD是有限制的，通过FD_SETSIZE设置，默认1024。


- POll

  poll本质和select没有区别，只是poll是基于链表来存储的，所有它没有最大连接数的限制。poll还有一个特点是采用了水平触发的通知策略，文件描述符就绪了会一直进行通知。

  - **水平触发**

    当关系描述符关联的读内核缓存区非空，有数据读取，就一直发出可读信号进行通知。当关系描述符关联的写内核缓存区不满，有空间写入，就一直发出可写信号进行通知。也就是fd变为就绪态会一直通知。

  - **边缘触发**

    和水平触发不同的是，边缘触发只有当读内核缓存区由空变为非空时才通知一次，或者是写内核缓存区由满变不满时通知一次，也就是**只在fd变为就绪态的时候通知一次**。

- epoll

  ![1649383300485](../img/1649383300485.png)

  ![](../img/epoll.awebp)

  第一步，创建一个 epoll 句柄int epoll_create(int size);第二步，向内核添加、修改或删除要监控的文件描述符。int epoll_ctl(  int epfd, int op, int fd, struct epoll_event *event);第三步，类似发起了 select() 调用int epoll_wait(  int epfd, struct epoll_event *events, int max events, int timeout);

  epoll是select和poll的增强版，使用了**事件**的触发机制。在epoll中，内核保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。而且也不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。每当有fd就绪，就将就绪fd放进就绪链表里面返回，时间复杂度为O（1），也就是说仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。使用epoll优点是只关注“活跃的”文件描述符，只有活跃的文件描述符才能进行回调返回到用户态，大大提高了效率

  ​



- 





## 二 进程和线程

### 2.1 进程和线程的区别

> 见java基础.md

### 2.2 进程有哪几种状态?

👨‍💻**面试官** ： 那你再说说**进程有哪几种状态?**

🙋 **我** ：我们一般把进程大致分为 5 种状态，这一点和线程很像！

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。这时候干的事情有：进程申请一个空白PCB进程控制块，并向PCB中填写用于控制和管理进程的信息，然后为进程分配运行时所需要的资源，最后将进程的状态切换为就绪状态并将其插入就绪队列中。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)** ：进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。通常操作系统会将阻塞状态的进程排成一个队列。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。要将PCB清零并将PCB空间返还给操作系统。

> 订正：下图中 running 状态被 interrupt 向 ready 状态转换的箭头方向反了。

![process-state](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/d38202593012b457debbcd74994c6292.png)

### 2.3 进程间的通信方式

👨‍💻**面试官** ：**进程间的通信常见的的有哪几种方式呢?**

🙋 **我** ：大概有 7 种常见的进程间的通信方式。

> 下面这部分总结参考了:[《进程间通信 IPC (InterProcess Communication)》open in new window](https://www.jianshu.com/p/c1015f5ffa74) 这篇文章，推荐阅读，总结的非常不错。

1. **匿名管道(Pipes)** ：匿名管道是特殊类型的文件，用于具有亲缘关系的父子进程间或者兄弟进程之间的通信，写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

   ![1648803584681](../img/1648803584681.png)

2. **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程恢复执行并传递给它为止。

4. **消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与存在于内存文件中的匿名管道，存在于实际的磁盘介质或者文件系统中的有名管道不同的是，消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。**

5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。因为只需进行2次数据的拷贝，而且会一直保持共享区域，所以说这是效率最高的进程间通信方式。

7. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

   ​

   ​

#### 共享内存的实现

> [实现原理](https://juejin.cn/post/6844903855235268615)

![共享内存](../img/共享内存.awebp)

共享内存是通过将不同进程的虚拟内存地址映射到相同的物理内存地址来实现。现代的cpu寻址使用的是虚拟寻址，使用虚拟寻址，cpu需要将虚拟地址翻译成物理地址，就可以访问到真实的物理内存。而虚拟内存为每个进程提供了一个连续完整的私有内存空间，不同进程的私有空间对应的虚拟地址映射到同一个物理内存地址就能实现内存的共享。

而实现进程虚拟内存地址与内存物理地址的映射采用的是**mmap方法**：

```
 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面(到对应的文件磁盘上),这样就完成了对文件的操作而不必再调用read,write等系统调用函数。

mmap适合对用一块内存频繁读写的情况，因为可以减少内存的拷贝次数，比如在read调用时，一个完整的流程是操作系统读磁盘文件到页缓存，再从页缓存将数据拷贝到read传递的buffer里，而如果使用mmap之后，操作系统只需要将磁盘读到页缓存，然后用户就可以直接通过指针的方式操作mmap映射的内存，减少了从内核态到用户态的数据拷贝次数，减少了系统调用的次数。

![1649314262987](../img/1649314262987.png)



### 2.4 线程间的同步的方式

👨‍💻**面试官** ：**那线程间的同步的方式有哪些呢?**

🙋 **我** ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以**避免**关键的资源使用冲突，让进程有次序的执行。操作系统一般有下面三种线程同步的方式：

1. **互斥信号量(Mutex)**：互斥信号量用于形成互斥关系，以同步他们的运行。为资源设置一个互斥信号量mutex，并设置初值为1，表示互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。在进入临界区之间需要对mutex执行wait操作，若资源此刻为被访问则成功访问资源，否则会阻塞。等访问该资源的进程释放资源后，会对mutex执行signal操作，这样就实现了两个进程互斥。

2. **同步信号量(Semphares)** ：同步信号量用于相互制约和传递消息，以同步他们的运行。比如要让一段代码c1先与另一段代码c2执行，只需定义同步信号量，其初始值为0，在c1后面对信号量进行signal操作，在c2代码段前面对信号量进行wait操作。如果c1没执行的话信号量就一直是0，c2wait操作的时候就会阻塞。

3. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持同步。

   ​

### 2.5 进程的调度算法

👨‍💻**面试官** ：**你知道操作系统中进程的调度算法有哪些吗?**

🙋 **我** ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！

为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：

> 用于作业调度和进程调度

- **先到先服务(FCFS)调度算法** : 最简单的调度算法，系统按作业到达的前后顺序来进行调度，从就绪队列中选择一个最先进入该队列的进程为之分配资源。

- **短作业优先(SJF)的调度算法** : 按运行时间来决定，时间越短，其优先级越高越先执行，它会从就绪队列中选择估计运行时间最短的进程，并为之分配CPU运行。

- **时间片轮转调度算法（RR)** : 时间片轮转调度是一种最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。一个时间片内没有运行完成的进程将返回到就绪队列的队尾等待下一次调度。

- **优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以先来先服务FCFS方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

- **多级反馈队列调度算法** ：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。它设置了多个就绪队列，为每个队列赋予不同的优先级，第一个队列的优先级最高，第一个队列次之，以此类推。优先级越高的队列其时间片越小，每个队列都采用先来先服务调度算法。第一个队列空闲时，才调度第二个队列的任务。

  ![1650454293582](img/1650454293582.png)

### 2.6 什么是死锁

👨‍💻**面试官** ：**你知道什么是死锁吗?**

🙋 **我** ：死锁描述的是这样一种情况：多个进程同时被阻塞，它们中的一个或者全部进程所等待的是事件是其他线程释放所占有的资源。所以进程被无限期地阻塞，因此程序不可能正常终止。

### 2.7 死锁的四个条件

👨‍💻**面试官** ：**产生死锁的四个必要条件是什么?**

🙋 **我** ：如果系统中以下四个条件同时成立，那么就能引起死锁：

- **互斥**：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
- **占有并等待**：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。
- **非抢占**：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。
- **循环等待**：有一组等待进程 `{P0, P1,..., Pn}`， `P0` 等待的资源被 `P1` 占有，`P1` 等待的资源被 `P2` 占有，......，`Pn-1` 等待的资源被 `Pn` 占有，`Pn` 等待的资源被 `P0` 占有。

注意，只有四个条件同时成立时，死锁才会出现。

### 2.8 解决死锁的方法

解决死锁的方法可以从多个角度去分析，一般的情况下，有**预防，避免，检测和解除四种**。

- **预防** 是采用某种策略，**限制并发进程对资源的请求**，从而使得死锁的必要条件在系统执行的任何时间上都不满足。
- **避免**则是系统在分配资源时，根据资源的使用情况**提前做出预测**，从而**避免死锁的发生**
- **检测**是指系统设有**专门的机构**，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。
- **解除** 是与检测相配套的一种措施，用于**将进程从死锁状态下解脱出来**。通常是撤销资源，回收资源。

#### 死锁的预防

死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。

破坏第一个条件 **互斥条件**：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 **往往是不能同时访问的** ，所以这种做法在大多数的场合是行不通的。

破坏第三个条件 **非抢占** ：也就是说可以采用 **剥夺式调度算法**，但剥夺式调度方法目前一般仅适用于 **主存资源** 和 **处理器资源** 的分配，并不适用于所以的资源，会导致 **资源利用率下降**。

所以一般比较实用的 **预防死锁的方法**，是通过考虑破坏第二个条件和第四个条件。

**1、静态分配策略**

静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。

静态分配策略逻辑简单，实现也很容易，但这种策略 **严重地降低了资源利用率**，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才是用的，这样就可能造成了一个进程占有了一些 **几乎不用的资源而使其他需要该资源的进程产生等待** 的情况。

**2、层次分配策略**

层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。

#### 死锁的避免

上面提到的 **破坏** 死锁产生的四个必要条件之一就可以成功 **预防系统发生死锁** ，但是会导致 **低效的进程运行** 和 **资源使用率** 。而死锁的避免相反，它的角度是允许系统中**同时存在四个必要条件** ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 **明智和合理的选择** ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。

我们将系统的状态分为 **安全状态** 和 **不安全状态** ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。

> 如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。

那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 **避免死锁算法** 就是银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，**银行家算法** 通过先 **试探** 分配给该进程资源，然后通过 **安全性算法** 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 **真的分配资源给该进程**。

银行家算法详情可见：[《一句话+一张图说清楚——银行家算法》open in new window](https://blog.csdn.net/qq_33414271/article/details/80245715) 。

操作系统教程树中讲述的银行家算法也比较清晰，可以一看.

死锁的避免(银行家算法)改善解决了 **资源使用率低的问题** ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 **安全性检查** ，需要花费较多的时间。

#### 死锁的检测

对资源的分配加以限制可以 **预防和避免** 死锁的发生，但是都不利于各进程对系统资源的**充分共享**。解决死锁问题的另一条途径是 **死锁检测和解除** (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 **乐观锁** ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 **死锁的预防和避免** 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。

这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 **定时地运行一个 “死锁检测”** 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。

##### 进程-资源分配图

操作系统中的每一刻时刻的**系统状态**都可以用**进程-资源分配图**来表示，进程-资源分配图是描述进程和资源申请及分配关系的一种有向图，可用于**检测系统是否处于死锁状态**。

用一个方框表示每一个资源类，方框中的黑点表示该资源类中的各个资源，每个键进程用一个圆圈表示，用 **有向边** 来表示**进程申请资源和资源被分配的情况**。

图中 2-21 是**进程-资源分配图**的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，由于存在 **占有和等待资源的环路** ，导致一组进程永远处于等待资源的状态，发生了 **死锁**。

![进程-资源分配图](https://javaguide.cn/assets/%E8%BF%9B%E7%A8%8B-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.31e353df.jpg)

进程-资源分配图中存在环路并不一定是发生了死锁。因为循环等待资源仅仅是死锁发生的必要条件，而不是充分条件。图 2-22 便是一个有环路而无死锁的例子。虽然进程 P1 和进程 P3 分别占用了一个资源 R1 和一个资源 R2，并且因为等待另一个资源 R2 和另一个资源 R1 形成了环路，但进程 P2 和进程 P4 分别占有了一个资源 R1 和一个资源 R2，它们申请的资源得到了满足，在有限的时间里会归还资源，于是进程 P1 或 P3 都能获得另一个所需的资源，环路自动解除，系统也就不存在死锁状态了。

##### 死锁检测步骤

知道了死锁检测的原理，我们可以利用下列步骤编写一个 **死锁检测** 程序，检测系统是否产生了死锁。

1. 如果进程-资源分配图中无环路，则此时系统没有发生死锁
2. 如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。
3. 如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 **既不阻塞又非独立的进程** ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 **消除所有的边** ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 **拓扑排序**)

#### 死锁的解除

当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：

1. **立即结束所有进程的执行，重新启动操作系统** ：这种方法简单，但以前所在的工作全部作废，损失很大。
2. **撤销涉及死锁的所有进程，解除死锁后继续运行** ：这种方法能彻底打破**死锁的循环等待**条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。
3. **逐个撤销涉及死锁的进程，回收其资源直至死锁解除。**
4. **抢占资源** ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。

## 三 操作系统内存管理基础

### 3.1 内存管理介绍

👨‍💻 **面试官**: **操作系统的内存管理主要是做什么？**

🙋 **我：** 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。

### 3.2 常见的几种内存管理机制

👨‍💻 **面试官**: **操作系统的内存管理机制了解吗？内存管理有哪几种方式?**

🙋 **我：** 这个在学习操作系统的时候有了解过。

内存管理简单分为**连续分配管理方式**和**非连续分配管理方式**这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 **块式管理** 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如**页式管理** 和 **段式管理**和**段页式管理**。

1. **块式管理** ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
2. **页式管理** ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
3. **段式管理** ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。

简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。

👨‍💻**面试官** ： 回答的还不错！不过漏掉了一个很重要的 **段页式管理机制** 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 **段页式管理机制** 中段与段之间以及段的内部的都是离散的。

🙋 **我** ：谢谢面试官！刚刚把这个给忘记了～

### 3.3 快表和多级页表

👨‍💻**面试官** ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！

🙋 **我** ：在分页内存管理中，很重要的两点是：

1. 虚拟地址到物理地址的转换要快。
2. 解决虚拟地址空间大，页表也会很大的问题。

#### 快表

为了解决虚拟地址到物理地址的转换速度，操作系统在 **页表方案** 基础之上引入了 **快表** 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。

使用快表之后的地址转换流程是这样的：

1. 根据虚拟地址中的页号查快表；
2. 如果该页在快表中，直接从快表中读取相应的物理地址；
3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

#### 多级页表

引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，当某个一级页表的页表项没有被用到，也就不需要创建这个页表项的二级页表了，节省了空间。

>  不论是快表还是多级页表实际上都利用到了程序的局部性原理。

### 3.4 分页机制和分段机制的共同点和区别

👨‍💻**面试官** ： **分页机制和分段机制有哪些共同点和区别呢？**

🙋 **我** ：

1. 共同点：


   - 分页机制和分段机制都是为了提高内存利用率，减少内存碎片。
   - 页和段都是离散存储的，允许一个程序使用的内存分布在离散或者说不相邻的内存中。但是，每个页和段中的内存是连续的。

2. 区别：


   - 页的大小是固定的，由操作系统决定，在每个系统中只有一种大小的页面；而段的大小不固定，取决于我们当前运行的程序。
   - 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。

### 3.5 逻辑(虚拟)地址和物理地址

👨‍💻**面试官** ：你刚刚还提到了**逻辑地址和物理地址**这两个概念，我不太清楚，你能为我解释一下不？

🙋 **我：** em...好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。



## 四 虚拟内存

### CPU虚拟寻址

现代处理器使用的是一种称为 **虚拟寻址(Virtual Addressing)** 的寻址方式。**使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。** 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 **内存管理单元（Memory Management Unit, MMU）** 的硬件。**MMU需要借助存放在内存中的页表来动态翻译虚拟地址，该页表由操作系统管理。**如下图所示：

![虚拟寻址](../img/虚拟寻址.awebp)

**为什么要有虚拟地址空间呢？**

- 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。
- 多个程序对同一个内存操作，可能会造成前一个程序对内存的赋值被后一个进程的赋值覆盖，这就进程崩溃。

**通过虚拟地址访问内存有以下优势：**

- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。
- 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。
- 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。

### **页表**

> 仅讨论单页表，实际生产环境中是采用层次结构的页表

页表就是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系。在进行动态内存分配时，例如`malloc()`函数或者其他高级语言中的`new`关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表。

![页表](../img/页表.awebp)

虚拟页`VP 0`、`VP 4`、`VP 6`、`VP 7`被缓存在物理内存中，虚拟页`VP 2`和`VP 5`被分配在页表中，但并没有缓存在物理内存，虚拟页`VP 1`和`VP 3`还没有被分配。

**缺页时：**

当CPU遇见缺页时会触发一个缺页异常，缺页异常将控制权转向操作系统内核，然后调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，如果牺牲页已被修改过，内核会先将它复制回硬盘（采用写回机制而不是直写也是为了尽量减少对硬盘的访问次数），然后再把该虚拟页覆盖到牺牲页的位置，并且更新PTE。

当缺页异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送给MMU*。由于现在已经成功处理了缺页异常，所以最终结果是页命中，并得到物理地址。

![缺页](../img/缺页.awebp)

### 虚拟内存

👨‍💻**面试官** ：再问你一个常识性的问题！**什么是虚拟内存(Virtual Memory)?**

🙋 **我** ：这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。**为什么可以这样呢？** 正是因为 **虚拟内存** 的存在，通过 **虚拟内存** 可以让程序可以拥有远远大于系统物理内存大小的可用内存空间。另外，**虚拟内存为每个进程提供了一个连续完整的私有内存空间**。这样会更加有效地管理内存并减少出错。

**虚拟内存**是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间**，并且 **把内存扩展到硬盘空间。

>  [《虚拟内存的那点事儿》](https://juejin.im/post/59f8691b51882534af254317)
>
>  这部分内容来自：[王道考研操作系统知识点整理](https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html)。

基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——**虚拟存储器**。

实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。

> 使用了虚拟内存，就可以主存看作为cpu和在硬盘上的虚拟地址空间之间的高速缓存，并且只在主存中缓存活动区域（按需缓存）。

### 局部性原理

👨‍💻**面试官** ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的**局部性原理**。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。

🙋 **我** ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。

局部性原理表现在以下两个方面：

1. **时间局部性原理** ：一个被访问过的内存地址在之后会有很大几率被再次访问（由于在程序中存在着大量的循环操作）。
2. **空间局部性原理** ：一个被访问过的内存地址以及其周边的内存地址都会有很大几率被再次访问（因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的）。

如果一个程序没有良好的局部性，将会使工作集的大小不断膨胀，直至超过物理内存的大小，这时程序会产生一种叫做抖动（thrashing）的状态，页面会不断地换入换出，如此多次的读写硬盘开销，性能自然会十分“恐怖”。**所以，想要编写出性能高效的程序，首先要保证程序的时间局部性与空间局部性。**





### 虚拟内存的技术实现

👨‍💻**面试官** ：**虚拟内存技术的实现呢？**

🙋 **我** ：**虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。** 虚拟内存的实现有以下三种方式：

1. **请求分页存储管理** ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。
2. **请求分段存储管理** ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。
3. **请求段页式存储管理**

**这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？**

请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。

它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。

不管是上面那种实现方式，我们一般都需要：

1. 一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；
2. **缺页中断**：如果**需执行的指令或访问的数据尚未在内存**（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段**调入到内存**，然后继续执行程序；
3. **虚拟地址空间** ：逻辑地址到物理地址的变换。

### 页面置换算法

👨‍💻**面试官** ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 **页面置换算法的作用?常见的页面置换算法有哪些?**

🙋 **我** ：

> 这个题目经常作为笔试题出现

地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。

> **缺页中断** 就是要访问的**页**不在内存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。

当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。

- **OPT 页面置换算法（最佳页面置换算法）** ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。
- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。
- **LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）** ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。
- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** : 该置换算法选择在之前时期使用最少的页面作为淘汰页。

## Reference