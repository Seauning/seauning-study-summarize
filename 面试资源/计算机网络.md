# 思维导图

![·](./img/computednetwork.awebp)

# 一、OSI 七层体系结构

## 应用层：

应用层负责为操作系统或网络应用程序提供访问网络服务的端口。常见的协议有 HTTP，FTP，TELNET、SMTP 等。

## 表示层：

表示层是确保一个系统的应用层发送的消息可以被另外一个系统的应用层读取，并处理用户信息的表示问题，如编码、数据格式转换和加密解密等。

## 会话层：

会话层则通过传输层建立数据传输的通道，在系统之间发起会话或者接受会话请求，并组织和协调两个会话进程之间的通信，对数据交换进行管理。

## 传输层：

传输层则在网络层的基础上，为应用进程之间的通信提供服务。根据用户需求，传输层有两种不同的传输协议，分别是面向连接的TCP协议和面向无连接的UDP协议。

## 网络层：

网络层主要向其上层只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。

## 数据链路层：

数据链路层则进行封装成帧，透明传输和差错检验，封装成帧是在网络层传递下来的IP数据报加上头部和尾部，透明传输是不管从键盘上输入什么字符都可以放在帧的数据部分然后传输过去。这其中使用了字节填充来解决数据中可能会出现控制字符的问题。差错检验是采用CRC循环冗余码来检测传输差错。

## 物理层：

物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，尽可能屏蔽掉传输介质和物理设备的差异。



## 为什么要对网络协议分层

1首先是为了保证各层之间的独立性，某一层可以使用下一层提供的服务而不需要知道其具体组成。

2.然后是灵活性好。当其中一层的技术发生变化时，只要层间接口关系保持不变，则其余各层均不受影响。也就是说某一层出现技术革新或者出现问题时不会连累到其它层的工作，排除问题时也只需要考虑这一层单独的问题即可。

3.还有易于实现和维护。进行调试和维护时，可以对每一层进行单独的调试。

4.最后是能促进标准化工作。标准化的好处就是可以随意替换其中的某一层，对于使用和科研来说十分方便。





# 二、TCP、UDP

 TCP(传输控制协议)、UDP(用户数据报协议 )

## 1 TCP 协议与 UDP 协议的特点(区别)

- TCP是面向连接的协议，发送数据前需要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的的数据不会丢失，没有重复，并且按时到达。
- UDP是无连接的协议，在发送数据前不需要先建议连接，是没有可靠性的协议。因为不需要先建议连接所以可以在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。
- TCP只支持点对点的全双工通信，UDP还支持一对一，一对多，多对一，多对多。
- TCP是面向字节流的，发送数据时以字节为单位，一个数据包可以拆分为若干组进行发送，而UDP是面向报文的，一个报文只能一次发完。
- TCP的首部开销20字节比UDP的首部开销8字节要大



##  TCP和UDP的应用场景

- 对某些实时性要求比较高的情况使用UDP，比如游戏，媒体通信，在线直播等。即使实现传输错误也是可以容忍的。其他大多数情况，比如HTTP、HTTPS、FTP等传输文件的协议，都是用的UDP，因为要求传输的内容可靠，不会出现丢失的情况。



## 2 TCP 的端到端连接（socket)

- 网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个socket。socket通常用来实现客户方和服务方的连接。socket是TCP/IP协议的一个十分流行的编程界面，一个socket由一个IP地址和一个端口号唯一确定



## 3 TCP 报文格式：

![](./img/tcp.png)

## 4 UDP 报文格式：

![](./img/udp.jpg)

## 5 三次握手

![](./img/threeHand.png)

- 三次握手的目的是建立可靠的通信信道，主要目的就是双方都确认自己与对方发送和接受都正常
- 刚开始客户端处于关闭状态，服务端处于监听状态
- 第一次握手，客户端将SYN置1，并随机产生一个初始序列号发送给服务端，进入SYN-send状态。这时服务端确认了对方发送正常
- 第二次握手，服务端以自己的SYN报文作为应答，将客户端的序列号加一作为ack的值，并随机产生一个自己的初始序列号发送给客户端，进入了SYN-RCVD状态，此时客户端确认了自己与对方发送与接受都正常，服务端确认了自己接受正常，对方发送正常。
- 第三次挥手，客户端收到SYN报文后，会发送一个ACK报文，也是一样把服务端的序列号加一作为ack的值，表示收到了服务端的SYN报文，进入了establish状态。此时客户端和服务端都确认了自己与对方发送和接受都正常，这三次握手都缺一不可。



## 6 三次握手的原因

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。设想一种情况：

如果客户端发送的连接请求在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。



## 7 四次挥手

![](./img/forWave.jpg)

- 第一次挥手，客户端发送一个FIN，用来关闭客户端到服务端的数据传送
- 第二次挥手，服务端收到这个FIN，它发回一个ACK，确认序号为收到的序号加一。一个FIN将占用一个序号。
- 此时客户端终止了数据发送，服务端还可以继续发送数据，发送完后进行第三次挥手
- 第三次挥手，服务端关闭与客户端的连接，发送一个FIN给客户端
- 客户端发回ACK报文确认，并将确认序号设置为收到的序号加一
- 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放的通知，对方确认后就完全关闭了TCP连接







## 8 四次挥手的原因

- 因为TCP是双向对等传输，有两个方向的连接，需要2个FIN才能断开。
- 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE- WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

## 9 等待 2MSL 的原因

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。

- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

## 10 TCP 可靠传输的工作原理

- 首先是应用数据被分割成TCP最适合发送的数据块，TCP给发送的每一个包进行排序，把有序的数据传送到应用层。

- 然后是检验和，TCP将保持它首部与数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化，收到的段的检验和有差错将会丢弃该报文。

- 最后是TCP的流量控制、拥塞控制、ARQ协议和超时重传机制等。

  ​



## ARQ协议

####    停止等待ARQ协议

- 每发送完一个分组就停止发送，等待对方确认，在收到确认之后再发送下一个分组。发送方只要在设定的时钟时间段内没有收到确认，就会认为发送的分组丢失，重传刚才发送的分组。**注意：** 发送方在发送完一个分组后需要暂时保存分组；分组和确认分组都必须编号；超时重传时间应比数据在分组传输的平均往返时间更长一些。
- **确认丢失和确认迟到两种情况：** 如果确认丢失发送方在超时计时器过期后会认为刚刚发送的分组错误，重传分组，而接受方在收到第二次相同分组时，会直接丢弃该分组并重新发起该分组的确认；如果确认迟到，发送方同样重传分组，接送方丢弃后重传确认，发送方会接受最先到达的确认，并丢弃后面到达的无用确认。
- 停止等待协议固然是简单、可靠的协议；但是信道利用率太低，改进方法是采用流水线传输。

####     连续 ARQ 协议

- 发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的**最后一个分组** 发送确认，**表明到这个分组为止的所有分组都已经正确收到了** 。
- 具有停止等待协议可靠、易实现的优点，且信道利用率高；但通信线路质量不好时，连续ARQ协议会带来负面的影响。比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。

## 滑动窗口(这部分即是连续 ARQ 的实现)

- 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接受方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其他信息来设置窗口大小
- 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到确认，那么发送窗口就会向右滑动一定的距离，直到左部第一个字节不是已发送并且收到了确认的状态。接收窗口类似，接收窗口左部字节已经确认并交付主机，就向右滑动一定距离，接收窗口只会对窗口内最后一个按序到达的字节进行确认。
- 发送缓存暂时存放发送应用程序传送给发送方 TCP 准备发送的数据；TCP 已发送出但尚未收到确认的数据。
- 接收缓存暂时存放按序到达的、但尚未被接收应用程序读取的数据；未按序到达的数据。

##  流量控制

1. 流量控制是为了控制发送方的发送速率，保证接收方来得及接受，接受方发送的确认报文中的窗口字段rwnd可以用来控制发送方窗口的大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。
2. 在双方停止发送数据包时，为了避免互相等待的死锁局面一直延续，在接收到报文窗口值为 0 的一端，会设置一个持续计时器，每当持续计时器到期，会发送一个 0 窗口探测报文段吗，如果对方会对这个报文确认给出窗口值，如果为 0 重新启动持续计时器，如果不为 0 变可以重新发送数据。

##  拥塞控制

- 拥塞控制是为了降低网络的拥塞控制，防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不至于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。为了进行拥塞控制，TCP的发送方要维持一个拥塞窗口的状态变量cwnd。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态改变。
- TCP 的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。

##  拥塞控制算法

- 慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。所以慢开始是由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，只发送一个报文段，每经过一个传播轮次，cwnd 加倍增加。

- 拥塞避免： 在拥塞窗口 >= 慢开始门限后，就采用拥塞避免算法，具体的思路是让拥塞窗口 cwnd 按线性规律缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1，如果出现了超时，则令 慢开始门限为拥塞窗口cwnd的一半，然后重新执行慢开始。

- 快重传与快恢复：
  快重传和快恢复能快速恢复丢失的数据包。如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段，提高了网络的吞吐量。当有单独的数据包丢失时，快重传能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

**补充：** 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh(慢开始门限)，这时候直接进入拥塞避免。发送方窗口的上限值应该是接收方窗口 rwnd 和拥塞窗口 cwnd 中较小一个即 上限值 = min(rwnd, cwnd)

# 应用层

## 1 HTTP(HyperText Transfer Protocol 超文本传输协议)

**本质：** 一种浏览器与服务器之间约定好的通信格式。

### 1.1 HTTP 请求报文

HTTP 请求报文结构主要由 `请求行+请求头+空行+请求体`   组成，一般来说 get 请求没有请求体

- 请求行：格式为请求方法 、请求URL、HTTP 协议及版本版本

- 请求头：是客户端发送给服务端的一些附加信息，比如客户端信息(浏览器版本，所使用的操作系统等)
  和响应内容相关优先级等信息。

  格式为属性名：属性值，如Connection:keep-alive

  - 报文头部字段名不区分大小写
  - 字段名不允许出现空格，不可以出现下划线\_
  - 字段名后必须为 :

- 空行

  用于区分头部和实体，如果头部中添加了一个空行，那么空行内容后面会全部视为请求体。

- 请求体

  将页面表单中的组件值通过键值对形式编码成一个格式化串。


### HTTP 响应报文


 HTTP响应报文结构主要由响应行、响应头和响应体组成

- 响应行：报文协议及版本，响应状态码及状态描述

- 响应头：属性名：属性值

- 响应体

  ​

### HTTP首部

HTTP 首部用于给服务器和客户端提供报文主体大小、使用的语言及认证消息等内容。首部字段由字段名和字段值构成，中间用冒号「:」隔开。有些首部是某些报文专用的，如请求首部只适用于请求报文中，有些通用些。按类型用途不同可以分为 5 类：

- 通用首部：服务器和客户端都可以使用的首部。

  ```
  Date: Sat, 19 Sep 2020 06:13:42 GMT  #报文创建日期时间
  Connection: keep-alive/Uprade    #	浏览器优先使用的连接类型
  Transfer-Encoding: chunked   #报文的传输编码方式
  (有如下编码方式：)
  chunked：数据分块形式发送。
  compress：采用 LZW (Lempel-Ziv-Welch)压缩算法。
  deflate：采用 zlib 结构和 deflate 压缩算法。
  gzip：采用 LZ77（Lempel-Ziv coding）压缩算法和 32 位 CRC 检验的编码方式。
  identity：不压缩处理或修改
  ```

  ​

- 请求首部：客户端想服务端发送请求报文，补充请求的附加内容、客户端信息、响应内容相关优先级等信息。

  ```
  Accept-Charset: utf-8    #告知服务器能发送哪些字符集
  Accept-Encoding: gzip, deflate    #告知服务器能发送哪些编码方式
  Host: test.test.com:8080  #提供接受请求的服务器主机号和端口号(如果是标准端口即可忽略)
  Referer: https://www.baidu.com/   #当前文档的 URL
  ```

  ​

- 响应首部：服务端向客户端返回响应报文中所使用的字段。补充响应的附加内容，也要求客户端提供额外的内容信息。

  ```
  Age: 20   #资源在代理缓存中存在的时间，单位为秒
  Location: http://www.baidu.com/test.html  #引导客户端访问另一个URL,通常配合3xx响应,提供重定向URL
  Server: Apache/2.4.38   #告知客户端当前服务器安装的应用程序信息
  Retry-After: 120   #告知客户端多久（具体日期或秒数）后再发送请求，主要配合状态码 503服务器正忙或                       3xx Redirect 响应
  ```

  ​

- 实体首部：补充实体主体的更多信息，如主体长度或 MIME 类型。

  ```
  Content-Encoding: gzip   #用于对特定媒体类型的数据进行压缩。告知客户端要用的解压方式：gzip,                                 compress, deflate, identity, br
  Content-Length: 15000    #响应消息体长度，单位为字节
  Expires: Mon, 21 Sep 2020 02:16:21 GMT     #指定日期/时间，超过即表示已过期。如果 Cache-Control                                            设置了 max-age 和 s-max-age，那么 Expires 会被忽略
  Last-Modified: Mon, 21 Sep 2020 02:16:21 GMT  #该实体最后修改时间
  ```

  ​


- 常见非标准字段（自定义）：HTTP 首部字段可以自定义。

  ```
  响应首部：
  X-XSS-Protection: 1   #控制浏览器 XXS 防护机制开关：0（关闭 XSS 过滤）或（开启 XSS 过滤）
  请求首部：
  DNT: 1      #拒绝被精准广告跟踪：0 （同意被跟踪） 或 1 （不同意被跟踪）
  ```

  ​



### 1.2 HTTP 特点

1. 灵活可扩展。

   语义上自由，只规定基本格式，其他部分没有严格的语法限制。传输媒体多样，支持文本、图片、视频等任意数据。

2. 可靠传输。

   HTTP 协议基于可靠的传输层协议 TCP。(可以扩展 TCP 为何可靠)

3. 请求响应模式。

   HTTP 采用一方发送一方接收，并且有发送就会有响应的模式。

4. 无状态。

   每次 HTTP 请求都是独立的、无关的，并且默认不需要保留状态信息。

### 1.3 HTTP 缺点

- HTTP 是无状态的协议，在需要长链接的场景中，需要保持大量的上下文信息，以免传输大量重复的信息。

- HTTP 的整个传输过程都是明文传输，传输的信息直接暴露给了外界，很容易被截取。

- 队头阻塞，如果 HTTP 开启长链接，共用一个 TCP 连接，同一时刻就只能处理一个请求，如果一个请求耗时过长，其他请求就只能处于阻塞状态。

### 1.4 常见的请求方法有哪几种

- GET：常用于获取资源
- POST：提交数据，上传数据
- PUT：修改数据
- DELETE：删除资源
- HEAD：获取资源的元信息，如用于确认资源更新的日期时间
- PATCH：常用于对资源进行部分修改
- OPTIONS：查询指定的 URL 能够支持的请求方法，如 CORS 跨域时的预检请求。
- CONNECT：建立连接隧道，用于代理服务器。
- TRACE：常用于追踪请求到响应这个过程的传输路径。

### 1.5 GET 与 POST 区别

GET 和 POST 请求的本质是相同的

**前提：** 基于 RFC 规范

- 作用不同，GET 多用于从服务端获取资源、POST 一般用来向服务端提交资源
- 参数传递方式不同，GET 的参数一般是通过 ? 跟在 URL 后面的，多个参数通过 & 连接；POST 的参数一般是包含在 请求体 中
- 安全性不同，GET 请求参数直接暴露在 URL 上，所以 GET 不能用来传递敏感信息
- 编码方式不同，GET 请求只能进行 URL 编码,只能接受 ASCLL 字符；POST 支持多种编码方式,application/x-www-form-urlencoded、multipart/form-data。
- 缓存机制不同，GET 请求会被浏览器主动缓存，而 POST 需要手动设置；GET 请求参数会被完整保留在浏览器历史记录里，而 POST 的参数不会保留；GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
- 从 TCP 角度来讲，GET 请求会把请求报文一次性发出，而大部分浏览器 POST 请求会分为两个 TCP 数据包，首先发送 header 部分，如果服务器响应 100 (表明继续操作)，然后发送 body 部分。(firefox 的 post 只发送一个 TCP 包)



### POST和PUT的区别

1、POST
用于提交请求，可以更新或者创建资源，是非幂等的
举例：
在用户注册功能上，每次提交都是创建一个用户账户，此时则用POST

2、PUT
用于向指定URL传送更新资源，是幂等的
举例：
比如用户修改密码，虽然提交的还是账户名跟用户密码这两个必填参数，但是每次提交都只是更新该用户密码，每次请求都只是覆盖原先的值，此时该用PUT

3、场景
当需要以更新的形式来修改某一具体资源时，

若该更新对应的URL多次调用结果一致，则用PUT
若每次提交相同的内容，最终结果不一致的时候，用POST





### 1.6 HTTP 响应状态码

- 1xx：信息性状态码，表示目前是协议处理的中间状态，还需要后续操作。

  - 100 Continue：常用于 POST 请求的第一个请求报文的响应，当服务器返回此代码表示已收到请求的第一部分，正在等待剩余部分。

  - 101 Switching Protocols：常用于在 HTTP 协议切换到 WebSocket 的时候，如果服务器同意变更，就会发生切换协议的状态码。

- 2xx：成功状态码，表示请求正常处理完毕。

  - 200 OK：服务器已成功处理了请求。

  - 204 No Content：请求已经成功处理，但是返回的响应报文不包含实体部分。

  - 206 Partial Content：常用在 HTTP**分块下载**和**断点续传**，会带上响应头字段 Content-Range

- 3xx：重定向状态码，表示需要进行附加操作以完成请求。

  - 301 Moved Permanently：永久性重定向。请求的网页已永久移动到新位置，服务器返回此响应时，会自动跳转到新的位置。例如网站从 HTTP 协议升级到 HTTPS 协议，这时候服务器就会返回 301 状态码，并且浏览器默认会作缓存优化，在第二次访问时自动访问重定向的 URL。

  - 302 Found：临时性重定向，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

  - 304 Not Modified：常用于协商缓存中服务器通知客户端资源未修改，可以继续使用缓存中的资源。

- 4xx：客户端错误状态码，说明客户端请求报文有误。

  - 400 Bad Request：请求报文中存在语法错误，但并没有具体出错原因。

  - 401 Unauthorized：请求要求身份验证。

  - 403 Forbidden：请求的资源服务器禁止访问。

  - 404 Not Found：服务器无法找到对应资源(未找到)

- 5xx：服务端错误状态码，服务器处理请求出错。

  - 500 Internal Server Error：服务器在执行请求时发生错误，具体原因未知。

  - 502 Bad Gateway：作为网关或代理角色的服务器，从上游服务器（如 tomcat、php-fpm）中接收到的响应是无效的。

  - 503 Service Unavailable：服务器暂时处于过载或进行停机维护，暂时无法响应服务。

### 1.7 常见的头部字段

- 数据格式，Content-Type/Accept

  发送端如果要发送数据，需要在请求头中添加数据格式字段。

  - text: text/html、text/plain、text/css
  - image: image/gif、image/png、image/jpeg
  - audio/video：audio/mpeg、video/mp4
  - application：application/json、application/javascript
  - multipart：multipart/form-data、multipart/byteranges

- 压缩方式，Content-Encoding/Accept-Encoding

  指定数据的压缩方式，常见的值有 gzip、deflate、br

- 语言，Content-Language/Accept-Language

  用于指定支持的语言，如果支持多种语言用 `, ` 分隔；
  常见的值有 zh-CN、zh、en

- 字符集，Content-Type/Accept-Charset

  发送端将采用的字符集放在 Content-Type 中；
  格式：Content-Type: text/html; charset=utf-8

- Web 认证信息，Authorization

- 客户端在这个域名下的 Cookie，Cookie

- HTTP 客户端程序的信息，User-Agent

- 响应报文
  Accept-Ranges (是否接受字节范围请求),
  Age (推算资源创建经过时间),
  ETag (资源的匹配信息),
  Location (令客户端重定向至指定 URI),
  Proxy-Authenticate (代理服务器对客户端的认证信息),
  Retry-After (对再次发起请求的时机要求),
  Server (HTTP 服务器的安装信息),
  Vary (代理服务器缓存的管理信息),
  WWW-Authenticate (服务器对客户端的认证信息)

### 1.8 HTTP 传输定长和不定长(分块传输)的包体

- 定长的包体涉及到 Content-Length 字段，如果手动将该字段的值设置的比传输的内容小，那么多余的字段会直接截取。如果设置的比传输内容大，响应的内容会出现错误。

- HTTP 通过分块传输不定长包体

  需要在响应头设置 Transfer-Encoding: chunked，开启这个字段后默认会采用长链接，并且 Content-Length 字段会被忽略。

  可以通过手动设置 Connection 字段为 keep-alive 开启长连接。

### 1.9 HTTP 的大文件传输(范围请求)

HTTP 通过服务器的**范围请求**来支持大文件传输，服务器端需要设置响应头的字段为 `Accpet-Ranges: bytes` 表明服务器支持范围请求。

而对于客户端需要指定要请求哪一部分的内容，通过设置请求头的 `Range` 字段，格式为`bytes=x-y` 例如 0-499、500- 分别表示开始到第 499 个字节、从第 500 个字节到文件终点。

服务器收到请求后，会验证客户端请求的范围是否违法，如果越界返回 416 状态码；否则会读取相应的片段，并返回 206 状态码。同时服务器需要添加 `Content-Range` 字段。

单段请求返回的响应：

```js
HTTP/1.1 206 Partial Content
Content-Length: 10
Accept-Ranges: bytes
Content-Range: bytes 0-9/100  // 0-9表示请求的范围，100表示总资源大小

i am xxxxx
```

多段请求返回的响应：

```js
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000010101
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes


--00000010101
Content-Type: text/plain
Content-Range: bytes 0-9/96

i am xxxxx
--00000010101
Content-Type: text/plain
Content-Range: bytes 20-29/96

eex jspy e
--00000010101--

```

在 Content-Type 字段中指定了两个值，multipart/byteranges 表示请求是多段请求，而 boundary=00000010101 是响应体中的分隔符，并且在最后的分隔末尾添加上--。

### 1.10 HTTP 中表单数据的处理

表单的提交方式，一般使用 POST 将提交的数据放在请求体中，并且有两种不同的 Content-Type 取值：

- application/x-www-form-urlencoded
  - 数据会被编码成以 & 分隔的键值对
  - 字符以 URL 编码方式编码
- multipart/form-data
  - Content-Type 还会包含 boundary，由浏览器指定
  - 数据会分为多个部分，每个部分间通过 boundary 指定的分隔符分隔，最后的分隔符会加上--
  - 各部分均有 HTTP 头部描述子包体

一般表单的提交采用 multipart/form-data 而不是 application/x-www-form-urlencoded ，因为没有必要做 URL 编码，会增加耗时和空间的占用。

### 1.11 HTTP 缓存（属于 Web 性能优化，也称为浏览器缓存）

**概念：** 通过复用缓存资源，减少了客户端等待时间和网络流量，同时也能缓解服务器端的压力。

- 涉及的参数

  - Expires，响应头，资源的过期时间
  - Cache-Control，请求/响应头，控制强缓存的逻辑。
  - If-Modified-Since，请求头，资源最近修改时间
  - Last-Modified，响应头，资源最近修改时间(配合 If-Modified-Since 使用)
  - Etag，响应头，资源标识，资源变化会导致 ETag 变化
  - If-None-Match，请求头，缓存资源标识(配合 Etag 使用)

- 强缓存，强制直接使用缓存  
  强缓存不会向服务器发送请求，直接从缓存中读取资源。在浏览器控制台的 network 选项中可以看到该请求返回 200 的状态码，并且 size 显示 from disk cache 或 from memory cache；

  - 约定过期时间 (Expires)

    - 浏览器第一次请求 a.js
    - 服务器发送 a.js 资源并设置的 Expires(资源过期时间)
    - 浏览器接收并缓存的 a.js ,记下该资源过期时间
    - 浏览器第二次请求 a.js 发现缓存中的 a.js 还未过期,直接使用
    - 浏览器第三次请求 a.js 发现 a.js 过期了，重新向服务器发请求获取资源

    **缺点：**缓存过期以后，服务器不管 a.js 有没有变化，都会重新读取磁盘上的 a.js 文件发送给浏览器。

  总结：服务器在每次浏览器请求资源时，在响应头中设定资源的过期时间，只要过期时间未达浏览器就直接使用缓存中资源

  - 增加相对时间控制(Cache-Control)
    - max-age: 缓存最大过期时间
    - no-cache: 可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。
    - no-store: 永远不缓存

  总结：除了第一次请求，其他每次请求浏览器会先检查 Cache-Control，以 Cache-Control 为准，没有 Cache-Control 再用 Expires。

  **强缓存缺点：** 如果服务器上更新了资源浏览器并不会拿到最新的资源

- 协商缓存，和服务器协商确认缓存能否使用

  协商缓存会先向服务器发送一个请求，服务器会根据这个请求的请求头的一些参数来判断是否命中协商缓存;如果命中，则返回 304 状态码并带上新的响应头通知浏览器从缓存中读取资源。

  - 服务器告诉浏览器资源上次修改时间(Last-Modified/If-Modified-Since)

    - 浏览器第一次请求 a.js

    - 服务器发送 a.js 资源,并设置的 Last-Modified (最近修改时间)及过期时间

    - 当 a.js 过期时,浏览器带上 If-Modified-Since（等于上一次请求的 Last-Modified）请求服务器

    - 服务器比较请求头里的 If-Modified-Since 时间和服务器上 a.js 的最近修改时间

      - 一致，告诉浏览器：你可以继续用本地缓存(304),并不再返回 a.js
      - 不一致，读取磁盘上的 a.js 文件返给浏览器，同时告诉浏览器 a.js 的最近的修改时间以及过期时间

    **缺点：**浏览器端可以随意 Exipres，导致缓存使用不精准；最近修改时间只能精确到秒(可能 a.js 在 1 秒内经常变动,并且 a.js 设置了无缓存)

  - 增加文件内容对比(Etag)

    - 浏览器第一次请求 a.js

    - 服务器发送 a.js 资源,同时告诉浏览器资源过期时间以及相对时间（Cache-Control：max-age=10），以及 a.js 上次修改时间，以及 a.js 的 Etag。

    - 10 秒内浏览器再次请求 a.js，不再请求服务器，直接使用本地缓存。

    - 10 秒后，浏览器再请求 a.js，带上最近修改时间和设置在 If-None-Match 的的上次 Etag 值 。

    - 服务器收到浏览器的 If-Modified-Since 和 Etag，发现有 If-None-Match，则比较 If-None-Match 和 a.js 的 Etag 值，忽略 If-Modified-Since 的比较。

    - Etag 和 If-None-Match 一致，则 a.js 文件内容没变化，服务器告诉浏览器继续使用本地缓存（304）。

### 1.12 长连接和短连接

- 长链接：客户端向服务端发起连接，服务端接受客户端连接，双方建立连接，客户端与服务端完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。长连接可以省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间。服务端有保活功能(防止长链接无数据交互长期不关闭)。客户端与服务端之间的连接如果一直不关闭的话，会随着客户端连接越来越多，迟早服务端会崩溃。

- 短连接：客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。信道利用率低。

  ​

### 1.13 URI 和 URL 的区别是什么

- URI(Uniform Resource Identifier) 是统一资源标志符，定位web上的每一种资源如：图片，文档，视频等，这里所谓的定位指的是web上的资源相对于主机server来说，存放在server上的详细路径
- URL是全球资源定位符的英文缩写，平时上网时在浏览器中输入的那个地址就是URL
- 虽然URI和URL都定义了资源是什么，但URL还定义了该如何访问资源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。我个人理解的话，只要能唯一标识资源的就是URI，在URI的基础上给出其资源的访问方式的就是URL
- **补充：** URI 包括 URL 和 URN，URN 是统一资源名称，用来定义一个资源的名称
  ![](./img/url.png)



### URL详细内容

​     `http://www.aspx.com:8080/news/index.jsp?boardId=5&id=1#name`

- 协议部分：代表网页使用的协议，比如HTTP，HTTPS，FTP等
- 域名部分：也可以使用IP地址作为域名部分
- 端口部分：非必须，如果省略的话http则默认80端口，https则默认443端口
- 虚拟目录部分：非必须，看服务器项目有没有添加虚拟目录
- 文件名部分：访问项目文件的名称
- 参数部分：get请求携带的参数
- 锚部分：非必须，用于定位网页上的位置











### 1.14 如何让 HTTP 有状态(Cookie、Session)

#### Cookie

HTTP 是一种无状态协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。

HTTP 为了实现有状态引入了 Cookie，本质上是浏览器中存储的一个很小的文本文件，内容以键值对的方式存储。

向同一个域名下发送请求，都会携带相同的 Cookie ，服务器便能通过 Cookie 拿到客户端的状态。在服务器中可以设置响应头的 Set-Cookie 字段对客户端写入 Cookie。在 Cookie 设置时便绑定了域名和路径，在发送请求前会对比请求的域名和路径是否匹配，不匹配请求头就不携带 Cookie。对于路径来说，如果使用 / 就表示绑定的域名下任意路径都允许使用 Cookie。

Cookie 的有效期可以通过 Expires(过期时间) 和 Max-Age(存活时间) 两个字段设置。

如果设置请求头带上了 Secure 就说嘛只能通过 HTTPS 传输 Cookie，如果 Cookie 字段添加了 HttpOnly ，则说明 Cookie 不能通过 js 访问(document.cookie)，只能通过 HTTP 协议传输。

Cookie 存储容量小，上限为 4kb、安全缺陷，会有 xss、csrf 攻击。

#### Session

那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。 在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。大部分情况下，通过在 Cookie 中附加一个 Session ID 来方式来实现 Session 跟踪(Cookie 禁用使用 URL 重写)。

### 1.15 HTTP 和 HTTPS 的区别

   1.https需要拿到ca证书，用来解决非对称加密中公钥来源的不安全性。

   2.端口不一样，HTTP 默认 80端口、HTTPS 默认 443端口

   3.http是超文本传输协议，信息明文传输，https则是具有安全性的ssl加密传输协议

   4.http的连接很简单，是无状态的，https则是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，比      http协议安全

### 1.16 HTTP1 `队头阻塞`解决方法

1. 采用并发连接，对一个域名允许分配多个长链接，等同于增加了任务队列，也就不至于一个队伍的任务阻塞其他所有任务。例如 Chrome 浏览器支持并发 6 个长链接。

2. 域名分片，在一个域名下分出多个二级域名，并且它们指向同样的一台服务器，这样在多个域名下有多个长链接，能够并发的长链接数就更多了。

### 1.17 HTTP 1.0 和 HTTP 1.1 的主要区别是什么

- HTTP1.0 中默认采用短连接、HTTP1.1 中默认采用长链接，即默认开启 Connection:keep-alive
- 新增了错误状态码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
- HTTP1.1 支持流水线(滑动窗口)、同时打开多个 TCP 连接、新增缓存处理指令 max-age

### 1.18 HTTP2 的改进(与 HTTP1.1 区别)

- 头部压缩

  支持 HTTP2 的浏览器和服务器会维护一份相同的静态表和动态表，以及内置一个哈夫曼编码表。

  静态表存储一些常见的头部，和一些常见的头部键值对。动态表初始时是空的，如果请求头头部字段命中静态表中的名称，那么就会将这份键值对加入到动态表中。这样下次请求或响应只需要用一个字节就可以表示，这个字节就是一个指向表中数据的地址。

  另外像 Cookie 字段的值就可以用哈夫曼编码，将所有出现的字符串加入到哈夫曼编码表，让多次出现的字符串的索引值尽可能短，传输时传输索引值，这样可以达到很高的压缩效率。

- 二进制分帧

  HTTP2 将原来 Headers + Body 的报文格式拆分成了一个个二进制的帧，一个 HTTP2 连接上可以同时发送多个帧，用 Headers 帧存放头部字段，Data 帧存放请求体数据，并且每个二进制帧可以设置优先级，让服务器优先处理重要的资源请求。

  二进制分帧层是处于应用层和传输层之间的中间层，所有信息都会从中经过转换。

  双方都可以给对方发送二进制帧，这种二进制帧的**双向传输的序列**，也叫做`流(Stream)`。HTTP2 用`流`在一个 TCP 连接上进行多个数据帧的通信。

  二进制分帧实现了乱序发送，在每个帧上都有一个流标记，在接收方接收完毕，会按照标记位的拼接成一整条信息。因此发送方可以并行发送数据，接收方可以并行返回确定，无需按照顺序返回。

  乱序指的是`不同 ID 的流`是乱序的，但`同一个 ID 的流`的帧一定是按顺序传输的，二进制帧到达后对方会将`Stream ID`相同的二进制帧组装成完整的请求报文或响应报文。

- 多路复用

  HTTP 会存在`队头阻塞`的问题，通过**并发连接**和**域名分配**并没有从 HTTP 本身解决问题，只是增加了 TCP 连接。也会带来额外的问题，多条 TCP 连接竞争有限的带宽，优先级高的请求不能优先处理。

  HTTP2 的多路复用基于二进制分帧，二进制分帧后，服务器收到的将不是一个完整的 HTTP 请求包文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有 HTTP 队头阻塞的问题。并且多路复用也可以并行发送请求，无需等待前面的请求的响应。

- 服务器推送

  HTTP2 中服务器不再是被动的接收请求，响应请求，它也能通过新建 `Stream` 向客户端发送消息。当 TCP 连接建立之后，如果浏览器请求一个 HTML 资源，服务器就可以在返回相应 HTML 资源的基础上将 HTML 中引用到的其他资源一起返回给客户端，减少客户端发送请求的次数。

  如果浏览器有缓存服务器就可能发送不必要的数据浪费带宽，因此一般只有在对某资源第一次请求时实现服务器推送。

  遵循同源策略。

### 1.19 TCP 队头阻塞

HTTP2 虽然解决了 HTTP 的队头阻塞问题，但并没有解决 TCP 的队头阻塞问题。

HTTP2 中将每个请求拆分成多个二进制帧，不同请求的二进制帧组合成 Stream，Stream 是 TCP 上的逻辑传输单元，这样 HTTP2 就达到了一条连接同时发送多个请求。

TCP 队头阻塞：在一条 TCP 连接上同时发送多个 Stream，假如此时第二个 Stream 的第三个二进制帧丢失，因为 TCP 的数据有严格的前后顺序，如果前面的数据没到达，就算后面的数据到达了也需要等待，这就造成了 TCP 阻塞。

### 1.20 基于 UDP 的 HTTP3

队头阻塞：因为 UDP 的数据包在接收端没有处理顺序，即使中间丢失一个包，也不会阻塞整条链接。

HTTP3 是基于 QUIC 层的应用层协议，只要是运行在 QUIC 是至上的 HTTP 协议就被称为 HTTP3。

HTTP3 对 TCP 的拥塞控制、流量控制做了改进将其应用在 UDP 上

拥塞控制

- 热拔插

  TCP 的拥塞控制策略需要在系统层面进行操作，HTTP 的拥塞控制在应用层操作，动态选择拥塞控制策略。

- 前向纠错

  一段数据被切分为 10 个包后，一次对每个包异或运算，异或运算结果作为前向纠错包与数据包一起传输，如果传输过程中有一个数据包丢失，那么可以根据剩余 9 个包以及前向纠错包推算出丢失的包的数据，也能用于校验数据正确性。

- 单调递增的 Packet Number

  使用 Packet Number 解决原始请求与超时重传请求 ACK 的歧义，例如一个包丢失了，那么它重传的包的 Packet 标识将是比原来的标识大的数。

- ACK Delay

  TCP 计算 RTT 没有考虑接收发收到数据和发送数据间的延迟，HTTP3 考虑了这段延迟。

- 更多的 ACK

  一般接收后回复都是发送一个 ACK，但每接收一个就返回一个 ACK 太麻烦了，所以采用了接收多个后再回复多个也就是 ACK BLOCK，TCP 采用了这样的机制，但是最多只能有 3 个 ACK BLOCK，HTTP3 最多可以有 256 个 ACK BLOCK。在丢包严重的网络下，更多 ACK BLOCK 可以减少重传次数。

## 2 **常见的应用层协议**

- HTTP：端口 80,TCP

- DNS：端口 53,UDP/TCP

- DHCP：端口 67/68,UDP

- FTP：端口 20/21,TCP

- TFTP(Trivial FTP,简单文件传输协议)：端口 53,TCP

- SMTP：端口 25,TCP

- TELNET：端口 23,TCP

- POP3(邮件读取协议)：端口 110,TCP

- IMAP(网际报文存取协议)：端口 143,TCP

  ​

# 在浏览器中输入 url 地址到显示主页的过程

- 首先是浏览器查询DNS，获取域名对应的IP地址：具体过程包括浏览器搜索自身的DNS缓存，搜索操作系统的DNS缓存、读取本地Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名

- 解析（此解析具有权威性）。如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地DNS服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询。

- 浏览器获得域名对应的IP地址之后，浏览器向服务器请求建立连接，发起三次握手。

- 查找缓存中有无该域名的 ip 地址

- DNS 解析得到 ip 地址

- TCP/IP链接建立起来后，浏览器向服务器发起HTTP请求。

- 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器。

- 浏览器解析并渲染视图，若遇到对js文件，css文件以及图片等静态资源的应用，则重复上述步骤完并向服务器请求这些资源。

- 浏览器根据其请求到的资源，数据渲染页面，最终向用户呈现一个完整的页面。

  ​

## 1 DNS 解析域名获取 IP 地址

![](./img/dns.png)



递归查询和迭代查询：

- 递归查询是本地DNS服务器以客户机的身份向其他域名服务器查询的过程属于递归查询。其他域名服务器再向网域内的域名服务器查询直到得到最终的IP地址告诉本机，而不是让主机自己进行下一步查询。
- 迭代查询是本地域名服务器向根域名服务器、顶级域名服务器、二级域名服务器查询。这些域名服务器告诉本地域名服务器下一步该去哪里查然后它再去查。

迭代查询就是本地域名服务器向根域名服务器查询，根域名服务器要么告诉该域名的 ip 地址，要么告诉本地域名服务器下一步应该去哪一个顶级域名服务器，本地域名服务器再去查找从根域名服务器得知的那个顶级域名服务器的 ip 地址，再去这个顶级域名服务器中查找是否存在该域名的 ip 地址，如果没找到该域名的 ip 地址，顶级域名服务器也会告诉本地域名一个二级域名服务器的 ip 地址，让本地域名服务器去二级域名服务器中查找，这个查询的过程就是迭代查询，最后找到了需要解析的 ip 地址就把这个结果返回给查询该域名的主机。



## 2 DNS 缓存

浏览器缓存，系统缓存，路由器缓存，ISP 服务器缓存，根域名服务器缓存，顶级域名服务器缓存，二级域名服务器缓存...

## 3 DNS 负载均衡

DNS 负载均衡，又叫做 DNS 重定向。CDN(Content Delivery Network)就是利用 DNS 的重定向技术，DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求，提供所需的内容。

## 4 HTTPS

HTTP 即 HTTP + SSL/TLS，HTTPS 协议需要在建立 TCP 连接后，进行 SSL 握手，客户端和服务端交换随机数确定会话密钥，在之后的数据通信中采用会话密钥进行加密(表示层)。

SSL 握手的流程：

1. 客户端生成一个随机数(client random)、以及能使用的加密方法发送给服务端
2. 服务端接收该随机数和加密方法，并生成一个随机数(server random)，并携带加密方法和自己的数字证书一起发给客户端
3. 客户端接收该随机数(到此为止加密方法确定，因为如果能使用的加密方法不同在服务端接收到的时候就已经断开连接)，客户端再生成一个随机数并从数字证书中取出公钥，用公钥加密该随机数并发送给服务端
4. 服务端接收该随机数并用自己的私钥解密，到此三个随机数生成完毕，客户端和服务端用这三个随机数生成会话秘钥，**注意：**前面两个随机数都是明文传输，只有第三个随机数采用非对称加密后再传输，因此 SSL 握手的安全性体现在**第三个随机数**。

在 `2` 这个步骤中，公钥的存放如果不采用数字证书，可能会出现中间人攻击

中间人拿到服务端的公钥，保留在自己身上并替换为自己的公钥，重新发送给客户端。  
而客户端在收到请求拿到公钥后，便会用这个公钥加密自己要发送的东西发送给服务端。  
中间人截取了客户端的发送的加密数据，并用自己的私钥去解密，中间人修改客户端要发送  
的信息为有害的信息，并用一开始截取的公钥加密发送给服务端。服务端用自己的私钥去解密，  
并执行了中间人修改后的有害操作。

![](./img/midp.awebp)

解决这个问题的办法就是借助第三方公证机构，服务端将自己的公钥和自己的个人信息包装成一个证书，凡是收到这个证书的客户就能确定是服务端的公钥，再进行安全地传输。

不过这个证书仍然可能被篡改，这时候就需要使用 `数字签名`，服务端将个人信息及其他必要信息用`hash算法`生成一个 `数字摘要`，只要`数字摘要`的内容被修改，使用该算法生成的`数字摘要`就会发生巨大改变(所以数字签名中的信息是不肯被篡改的)。

然后公证处用自己的 `私钥` 对 `数字摘要` 进行加密，生成`数字签名`，最后将服务端的`原始信息`与`数字签名`合并为`数字证书`，之后每次服务器要给客户端发送公钥时，就发送自己的数字证书。

客户端收到数字证书后，从证书中拿到 `hash算法` 将数字证书上的服务端原始信息转化为 `数字摘要` ，再用公证处的公钥对数字签名进行解密，也生成一个 `数字摘要`，所以如果此时服务端的信息被篡改了 `数字摘要` 就会出现很大的变动，所以就解决了中间人攻击的问题。
